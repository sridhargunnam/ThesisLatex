\chapter{Proposed mechanisms for energy and performance savings}

	Technique $\Rightarrow$ Benefits  \newline

1) Hardware software co-design: Re-using motion vectors generated by ISP stage to reduce the re-reference of previous image frames to calculate motion vectors for optical flow generation.
(How to check if we need to compute everything with intensive vision algorithms or just use the precious results, what granularity to compute. Eg. Pyramids updating. Reactive to reconfiguration and powering on and off.)
	a) Reduction of DRAM capacity requirement
	b) Reduction of DRAM bandwidth requirement
	c) Reducing end-to-end latency in generating dense optical flow
\newline
2) Data driven execution: Use of motion vectors and previous optical flow to update the pyramids to make use intrinsic properties of foreground, background and motion in the scene.
	a) Reduces the number of computations 
		i) For building pyramids.
		ii) For calculating SAD(Sum of Absolute differences) during pyramid block matching.
	b) Reduces off-chip accesses
	c) Reduce end-to-end latency
\newline

3) Streaming Architecture: Using raster buffers across the entire optical flow pipeline.(Number of rows is constrained by maximum motion in the scene)
a) Helpful for scalability to higher resolution
b) Reduces size of local SRAM and off-chip memory access.
\newline

Case for low power 360 capture. Real time Stitching 30fps >4k resolution with low power. 
Latency of GPU, CPU makes them unusable for vision tasks in AR, VR.
Case for algorithm software Co-Design for a line buffer based streaming architecture. \newline


1) Energy Characterization of end-to-end pipeline\newline
Camera, ISP, Computation \newline
Split of energy in computation \newline
\newline
2) Runtime Characterization \newline
a) End-to-end pipeline\newline
b) Split in computation execution\newline
\newline
3) Performing motion estimation prior to computation stage\newline
a) Savings in DRAM capacity, bandwidth(Normalized) \newline
b) Savings in DRAM Bandwidth\newline
c) Savings in overall energy\newline
d) End-to-end latency reduction\newline
\newline
4) Optimizing of computation in pyramids \newline
a) The execution time split for creation of pyramid, finding optical flow of pyramid, refining/updating the pyramids, upscaling the pyramid. \newline
98 percent is to generate optical flow(dense pixel correspondence). But only 20-30 percent actually needs to be recomputed.\newline
Main optical flow method time is 0.560256
Total time for entire optical flow is 0.584954   
 

 5) Sense the environment in gray scale and perform color mapping later? How much are you saving? 
	



